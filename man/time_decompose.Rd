% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_decompose.R
\name{time_decompose}
\alias{time_decompose}
\title{Decompose a time series in preparation for anomaly detection}
\usage{
time_decompose(data, target, method = c("stl", "twitter", "multiplicative"),
  frequency = "auto", ..., merge = FALSE, message = TRUE)
}
\arguments{
\item{data}{A \code{tibble} or \code{tbl_time} object.}

\item{target}{A column to apply the function to}

\item{method}{The time series decomposition method. One of \code{"stl"}, \code{"twitter"}, or
\code{"multiplicative"}. The STL method uses seasonal decomposition (see \code{\link[=decompose_stl]{decompose_stl()}}).
The Twitter method uses \code{median_spans} to remove the trend (see \code{\link[=decompose_twitter]{decompose_twitter()}}).
The Multiplicative method uses multiplicative decomposition (see \code{\link[=decompose_multiplicative]{decompose_multiplicative()}}).}

\item{frequency}{Controls the seasonal adjustment (removal of seasonality).
Input can be either "auto", a time-based definition (e.g. "2 weeks"),
or a numeric number of observations per frequency (e.g. 10).
Refer to \code{\link[=time_frequency]{time_frequency()}}.}

\item{...}{Additional parameters passed to the underlying method functions.}

\item{merge}{A boolean. \code{FALSE} by default. If \code{TRUE}, will append results to the original data.}

\item{message}{A boolean. If \code{TRUE}, will output information related to \code{tbl_time} conversions, frequencies,
and median spans (if applicable).}
}
\value{
Returns a \code{tbl_time} object.
}
\description{
Decompose a time series in preparation for anomaly detection
}
\details{
The \code{time_decompose()} function generates a time series decomposition on
\code{tbl_time} objects. The function is "tidy" in the sense that it works
on data frames. It is designed to work with time-based data, and as such
must have a column that contains date or datetime information. The function
also works with grouped data. The function implements several methods
of time series decomposition, each with benefits.

\strong{STL}:

The STL method (\code{method = "stl"}) implements time series decomposition using
the underlying \code{\link[=decompose_stl]{decompose_stl()}} function. If you are familiar with \code{\link[stats:stl]{stats::stl()}},
the function is a "tidy" version that is designed to work with \code{tbl_time} objects.
The decomposition separates the "season" and "trend" components from
the "observed" values leaving the "remainder" for anomaly detection.
The main parameter that controls the seasonal adjustment is \code{frequency}.
Setting \code{frequency = "auto"} will lets the \code{\link[=time_frequency]{time_frequency()}} function
automatically determine the frequency based on the scale of the time series.

\strong{Twitter}:

The Twitter method (\code{method = "twitter"}) implements time series decomposition using
the methodology from the Twitter \href{https://github.com/twitter/AnomalyDetection}{AnomalyDetection} package.
The decomposition separates the "seasonal" component and then removes
the median data, which is a different approach than the STL method for removing
the trend. This approach works very well for low-growth + high seasonality data.
STL may be a better approach when trend is a large factor.
The user can control two parameters: \code{frequency} and \code{median_spans}.
The \code{frequency} parameter adjusts the "season" component that is removed
from the "observed" values. The \code{median_spans} parameter adjusts the
number of median spans that are used. The user may supply both \code{frequency}
and \code{median_spans} as time-based durations (e.g. "6 weeks") or numeric values
(e.g. 180) or "auto", which predetermines the frequency and/or median spans
based on the scale of the time series.

\strong{Multiplicative}:

The Multiplicative method (\code{method = "multiplicative"}) time series decomposition
uses the \code{\link[stats:decompose]{stats::decompose()}} function with \code{type = "multiplicative"}. This
method is useful in circumstances where variance is non-constantant and typically
growing in a multiplicative fashion. The parameters are the same as the STL method.
Alternatively, users may wish to try a transformation (e.g. \code{log()} or \code{sqrt()}) in combination
with the STL method to get near-constant variance.
}
\examples{

library(dplyr)

data(tidyverse_cran_downloads)

# Basic Usage
tidyverse_cran_downloads \%>\%
    time_decompose(count, method = "stl")

# twitter + median_spans
tidyverse_cran_downloads \%>\%
    time_decompose(count,
                   method       = "twitter",
                   frequency    = "1 week",
                   median_spans = "3 months",
                   merge        = TRUE,
                   message      = FALSE)

}
\seealso{
Decomposition Methods (Powers \code{time_decompose})
\itemize{
\item \code{\link[=decompose_stl]{decompose_stl()}}
\item \code{\link[=decompose_twitter]{decompose_twitter()}}
\item \code{\link[=decompose_multiplicative]{decompose_multiplicative()}}
}

Time Series Anomaly Detection Functions (anomaly detection workflow):
\itemize{
\item \code{\link[=anomalize]{anomalize()}}
\item \code{\link[=time_recompose]{time_recompose()}}
}
}
